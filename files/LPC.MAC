	.TITLE	LPC	LPC driver process
	.NLIST	BEX
	.ENABL	LC
;
; Pdp11/dcn lpc driver process
;
; LPCM data consists of bit-serial synchronous stream at 2400 bps.
; The bit stream is divided into 49-bit frames which encode the LPCM
; parameters for 20-ms intervals of the speech signal.  The 49 bits
; are broken up into 13 variable-sized data words, each of which
; is transmitted least-significant-bit first:
;
;   Bit 0:       Toggling bit
;   Bits 1..7:   Pitch, or = 5 if unvoiced
;   Bits 8..12:  Energy
;   Bits 13..18: K0	Bits 19..24: K1
;   Bits 25..28: K2	Bits 29..32: K3
;   Bits 33..35: K4	Bits 36..38: K5
;   Bits 39..41: K6	Bits 42..44: K7
;   Bits 45..46: K8	Bits 47..48: K9
; 
; The toggling bit changes in each frame, and can be used to figure out
; where the frame boundaries are. During silence the Pitch value of 5 for
; unvoiced data can also be helpful.
;
; Each LPCM frame is packed into a parcel of 8 octets in the following format:
;
;   | Octet 1                       | Octet 0
;   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
;   | T |                   Repeat Count                            |
;   +-------------------------------+-------------------------------+
;
;   | Octet 3                       | Octet 2
;   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
;   |  K0 low       |       Energy      |       Pitch               |
;   +-------------------------------+-------------------------------+
;
;   | Octet 5                       | Octet 4
;   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
;   |      K3       |      K2       |          K1           | K0 hi |
;   +-------------------------------+-------------------------------+
;
;   | Octet 7                       | Octet 6
;   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
;   |  K9   |  K8   |     K7    |     K6    |     K5    |     K4    |
;   +-------------------------------+-------------------------------+
;
; Note: A parcel (64 bits) of zeros is interpreted as end-file. A repeat
; count of zero is interpreted as one. The T bit is included on input as
; received from the LPCM, but is ignored on output and regenerated by the
; driver.
;
; External symbols
;
	.GLOBL	.WAIT,.SKED
;
; Entry symbols
;
	.GLOBL	LPCPAT		;process control vector
;
; System definitions
;
	.ASECT
	.MCALL	.COM,.PSA,.DFBLK,.SPD,.PAT ;dcnlib definitions
	.MCALL	.SETV,.GETDA,.PUTDA,.WIND ;dcnlib macros
	.COM			;define common data
	.PSA			;define process save area
	.DFBLK
	.LIST	ME
	.SPD			;define disk parameters
	.NLIST	ME
;
; Module definitions
;
FRMSIZ	=	49.		;frame size (bits)
PRCSIZ	=	8.		;parcel size
FIFSIZ	=	32.		;fifo circular buffer size (parcels)
VMBSIZ	=	4096./PRCSIZ	;size of virtual window (parcels)
EOFCNT	=	3*50.		;eof interval (3 sec)
SYNCH	=	000		;synch pattern (zilch)
TSOM	=	000400		;transmit som bit
;
; Status bits (flags)
;
SYNBIT	=	000001		;lpcm synch
RECREQ	=	000002		;receive request
RECBIT	=	000004		;receive mode
XMTREQ	=	000010		;transmit request
XMTBIT	=	000020		;transmit mode
EOFBIT	=	000040		;end of file bit
;
; Extended interrupt codes
;
INIT	=	002+EXTBAS	;initialize
RDBUF	=	003+EXTBAS	;read buffer
INTR	=	004+EXTBAS	;input interrupt
WRBUF	=	005+EXTBAS	;write buffer
INTX	=	006+EXTBAS	;output interrupt
;
; Process save area extension (lpc)
;
.	=	PSAEND
DASPAR:	.BLKW	SD.END/2	;parameter message
WRDMAX:	.BLKW	1		;max word count
VMBCNT:	.BLKW	1		;virtual-window count
NVOICE:	.BLKW	1		;parcels since last voice
INPSHF:	.BLKW	1		;input parcel shift pointer
INPCNT:	.BLKW	1		;input bit counter
OUTSHF:	.BLKW	1		;output shift register
OUTCNT:	.BLKW	1		;output bit counter
FLAGS:	.BLKW	1		;flags that wave
LPCLOK:	.BLKW	1		;parcel clock
PMAX:	.BLKW	2		;receiver phase
OVERUN:	.BLKB	2		;overrun/underrun
AMAX:	.BLKB	2		;receiver max weight
OUTOFS:	.BLKB	1		;output parcel offset
	.EVEN
;
PARCEL:	.BLKW	4		;parcel latch
;
FIFBGN:	.BLKW	1		;beginning of fifo buffer
FIFEND:	.BLKW	1		;end of fifo buffer
FIFPUT:	.BLKW	1		;fifo buffer put pointer
FIFGET:	.BLKW	1		;fifo buffer get pointer
FIFREC:	.BLKW	1		;fifo buffer receive pointer
FIFCNT:	.BLKW	1		;fifo buffer parcel count
FIFBUF:	.BLKW	PRCSIZ*FIFSIZ/2	;fifo circular buffer
;
FRMBGN:	.BLKW	1		;beginning of frame buffer
FRMEND:	.BLKW	1		;end of frame buffer
FRMPTR:	.BLKW	1		;frame buffer pointer
FRMBUF:	.BLKW	FRMSIZ		;frame buffer
	.EVEN
	.BLKW	REGEND/2+10	;process stack
LPCEND	=	.		;end of lpc extension
;
; Device register block (dev)
;
.	=	0
INPCSR:	.BLKW	1		;input status register
INPBUF:	.BLKW	1		;input buffer/parameter register
OUTCSR:	.BLKW	1		;output status register
OUTBUF:	.BLKW	1		;output buffer register
	.PAGE
;
; Procedure segment
;
; Two buffers are used in this implementation, one as a matched filter
; (FRMBUF) to recover frame synchronization and the other as a fifo queue
; (FIFBUF) to decouple the real-time device and i/o requests. The matched
; filter saves the last common multiple of 8 and 49 bits (8*49 = 392 bits)
; in a circular buffer, integrates the occurence of (unvoiced) synchronization
; patterns for each 8-bit byte and selects the synchronization point
; associtated with the largest integrator value.
;
; In idle mode the fifo queue is used to buffer parcels for local playback
; (sidetone). In receive mode the queue is used to buffer parcels to the
; user buffer and the sidetone is replaced by silence. Receive mode is ended
; by either loss of synch or silence timeout. In transmit mode the queue is
; used to buffer parcels from the user buffer. Transmit mode is ended by queue
; underflow.
;
; Flag bits
; recreq	set on input request (rdbuf), cleared on input complete.
; recbit	set on switch to receive mode, cleared when eofbit is cleared.
; eofbit	set in receive mode to terminate input or on loss of synch.
;		cleared on input complete.
; xmtreq	set on output request (wrbuf), cleared on output complete.
; xmtbit	set on switch to transmit mode, cleared on fifo underflow.
; synbit	set on synch acquire, cleared on synch loss.
;
; Supervisor-state procedure
; Dsects: r2 = dev, r3 = par, r4 = reg, r5 = psa
;
	.PSECT	$KERI,RO,I
;
; Initialization
;
LPCNIT:	MOV	R5,R0		;set fifo circular buffer pointers
	ADD	#FIFBUF,R0
	MOV	R0,FIFBGN(R5)
	MOV	R0,FIFPUT(R5)
	ADD	#PRCSIZ,FIFPUT(R5)
	MOV	R0,FIFGET(R5)
	MOV	R0,FIFREC(R5)
	MOV	R0,FIFEND(R5)
	ADD	#PRCSIZ*FIFSIZ,FIFEND(R5)
	MOV	R5,R0		;set frame buffer pointers
	ADD	#FRMBUF,R0
	MOV	R0,FRMBGN(R5)
	MOV	R0,FRMPTR(R5)
	ADD	#FRMSIZ*2,R0
	MOV	R0,FRMEND(R5)
	MOV	#000126,INPCSR(R2) ;initialize device registers
	MOV	#043400+SYNCH,INPBUF(R2)
	MOV	#000120,OUTCSR(R2)
	MOV	#TSOM,OUTBUF(R2)
	MOV	#SHFTAB,INPSHF(R5) ;initialize miscellany
	RTS	PC
;
; Start block transfer input
;
LPCSIR:	BIC	#17,REGPS(R4)	;reset cc for eof indication
	BIS	#RECREQ,FLAGS(R5) ;request receive mode
	JSR	PC,.WAIT
LPC15:	BIT	#RECREQ,FLAGS(R5) ;is receive active
	BEQ	4$		;branch if no
	BIT	#RECBIT,FLAGS(R5)
	BEQ	4$		;branch if no
	BIT	#EOFBIT,FLAGS(R5) ;yes. is eof set
	BEQ	1$		;branch if no
	BIS	#1,REGPS(R4)	;yes. set c bit in cc
	BIC	#RECBIT+EOFBIT,FLAGS(R5)
	BR	3$
;
1$:	TST	FIFCNT(R5)	;is buffer empty
	BLE	4$		;branch if yes
	MOV	FIFREC(R5),R1	;no. return pointer to next parcel
	MOV	R1,@R4
	ADD	#PRCSIZ,R1	;update parcel pointer
	CMP	R1,FIFEND(R5)
	BLO	2$
	MOV	FIFBGN(R5),R1
2$:	MOV	R1,FIFREC(R5)
	DEC	FIFCNT(R5)
3$:	BIC	#RECREQ,FLAGS(R5)
	JMP	.SKED		;schedule process
;
4$:	RTS	PC		;nothing doing
;
; Device interrupt input
;
LPCINR:	MOV	INPBUF(R2),R0	;is overrun indicated
	BPL	1$		;branch if no
	INCB	OVERUN(R5)	;yes. remember that fact
1$:	CLR	-(SP)		;initialize weight
	MOV	FRMPTR(R5),R1
	CMPB	R0,1(R1)	;is this synch pattern
	BNE	3$		;branch if no
	CMPB	R0,#012
	BEQ	2$		;branch if yes
	CMPB	R0,#013
	BNE	3$		;branch if no
2$:	MOV	#377,@SP	;yes. set weight max
3$:	MOVB	R0,1(R1)	;store current sample
	CLR	R0		;update smoothed weight
	BISB	@R1,R0
	SUB	R0,@SP
	ASR	@SP
	ASR	@SP
	ASR	@SP
	ADD	(SP)+,R0
	MOVB	R0,@R1
	CMPB	R0,AMAX+1(R5)	;is this new max
	BLO	4$		;branch if no
	MOVB	R0,AMAX+1(R5)	;yes. save weight and phase
	MOV	FRMPTR(R5),PMAX+2(R5)
4$:	CMP	R1,PMAX(R5)	;is this initial phase
	BNE	LPC20		;branch if no
	CLR	INPCNT(R5)	;yes. reset phase if necessary
	MOV	#SHFTAB,INPSHF(R5)
	BIT	#SYNBIT,FLAGS(R5) ;is this synchronized
	BNE	5$		;branch if yes
	BIS	#SYNBIT,FLAGS(R5) ;no. do that little violence
	MOV	FIFBGN(R5),FIFPUT(R5)
	ADD	#PRCSIZ,FIFPUT(R5)
	MOV	FIFBGN(R5),FIFGET(R5)
	MOV	FIFBGN(R5),FIFREC(R5)
	CLR	FIFCNT(R5)
	CLR	OUTCNT(R5)
	CLRB	OUTOFS(R5)
5$:	BIT	#XMTBIT+RECBIT,FLAGS(R5) ;is mode already set
	BNE	LPC20		;branch if yes
	BIT	#RECREQ,FLAGS(R5) ;no. is this receive request
	BEQ	6$		;branch if no
	BIS	#RECBIT,FLAGS(R5) ;yes. make the switch now
	CLR	PARCEL(R5)	;reset parcel latch
	CLR	PARCEL+2(R5)
	CLR	PARCEL+4(R5)
	CLR	PARCEL+6(R5)
	BR	LPC20
;
6$:	BIT	#XMTREQ,FLAGS(R5) ;is transmit mode requested
	BEQ	LPC20		;branch if no
	BIS	#XMTBIT,FLAGS(R5) ;yes. make the switch now
;
; Update parcel
;
LPC20:	BIT	#SYNBIT,FLAGS(R5) ;is receiver in synch
	BEQ	LPC10		;branch if no
	BIT	#XMTBIT,FLAGS(R5) ;yes. is this transmit mode
	BNE	LPC10		;branch if yes
	MOV	@R1,R0		;no. assemble shifted byte
	MOV	INPSHF(R5),R1
	ASH	(R1)+,R0
	BIC	(R1)+,R0
	MOV	FIFPUT(R5),R1
	TST	INPCNT(R5)	;is this new run
	BNE	1$		;branch if no
	ADD	#PRCSIZ-1,R1	;yes. re-align pointer if necessary
	SUB	FIFBGN(R5),R1
	BIC	#PRCSIZ-1,R1
	ADD	FIFBGN(R5),R1
	CLR	(R1)+
	TSTB	-(R1)
1$:	BISB	R0,(R1)+	;insert next byte
	BIC	#377,R0
	ADD	#8.,INPCNT(R5)	;update bit count
	CMP	INPCNT(R5),#FRMSIZ ;is this end of parcel
	BLO	4$		;branch if no
	INC	FIFCNT(R5)	;yes. update parcel count
	CMP	R1,FIFEND(R5)	;adjust buffer pointer
	BLO	2$
	MOV	FIFBGN(R5),R1
2$:	SUB	#FRMSIZ,INPCNT(R5) ;adjust bit count modulo frame size
	BNE	3$		;branch if end of run
	MOV	#SHFTAB,INPSHF(R5) ;reset phase
	BR	5$
;
3$:	ADD	#4,INPSHF(R5)	;advance phase
	CLRB	(R1)+
	ASR	R0
	MOVB	R0,(R1)+
4$:	SWAB	R0		;insert left-over bits
	MOVB	R0,@R1
5$:	MOV	R1,FIFPUT(R5)
;
; Advance to next phase
;
LPC10:	ADD	#2,FRMPTR(R5)	;advance buffer pointer
	CMP	FRMPTR(R5),FRMEND(R5) ;is this end of buffer
	BLO	1$		;branch if no
	MOV	FRMBGN(R5),FRMPTR(R5) ;yes. reset pointer and phase info
	MOVB	AMAX+1(R5),AMAX(R5)
	CLRB	AMAX+1(R5)
	MOV	PMAX+2(R5),R1
	CMP	PMAX+2(R5),PMAX(R5) ;is phase correction necessary
	BEQ	1$		;branch if no
	MOV	PMAX+2(R5),PMAX(R5) ;yes. reset
	BIC	#SYNBIT,FLAGS(R5)
	BIT	#RECBIT,FLAGS(R5) ;is this read mode
	BEQ	1$		;branch if no
	BIS	#EOFBIT,FLAGS(R5) ;yes. flag for eof
1$:	JMP	LPC15
;
; Start block transfer output
;
LPCSIX:	BIS	#XMTREQ,FLAGS(R5) ;request transmit mode
	JSR	PC,.WAIT
LPC30:	BIT	#XMTREQ,FLAGS(R5) ;is transmit active
	BEQ	2$		;branch if no
	BIT	#XMTBIT,FLAGS(R5)
	BEQ	2$		;branch if no
	CMP	FIFCNT(R5),#FIFSIZ-1 ;yes. is buffer full
	BGE	2$		;branch if yes
	MOV	FIFPUT(R5),R1	;no. return pointer to next parcel
	MOV	R1,@R4
	ADD	#PRCSIZ,R1	;update parcel pointer
	CMP	R1,FIFEND(R5)
	BLO	1$
	MOV	FIFBGN(R5),R1
1$:	MOV	R1,FIFPUT(R5)
	INC	FIFCNT(R5)
	BIC	#XMTREQ,FLAGS(R5)
	JMP	.SKED		;schedule process
;
2$:	RTS	PC		;nothing doing
;
; Device interrupt output
;
LPCINX:	MOV	OUTSHF(R5),R0	;complete residual shift
	MOV	OUTCNT(R5),R1
	NEG	R1
	ASH	R1,R0
	ADD	#8.,R1
1$:	MOV	R0,OUTSHF(R5)
	MOVB	OUTOFS(R5),R0	;is this first word of parcel
	BNE	2$		;branch if no
	INC	LPCLOK(R5)	;yes. assemble toggle bit
	MOVB	LPCLOK(R5),OUTSHF+1(R5)
	MOV	#1,OUTCNT(R5)
	INCB	OUTOFS(R5)
	BIT	#XMTBIT+RECBIT,FLAGS(R5) ;is this idle mode
	BNE	5$		;branch if no
	MOV	FIFGET(R5),R0	;yes. reduce sidetone a few db
	MOV	2(R0),-(SP)
	BIC	#^C7600,@SP
	ASR	@SP
	ASR	@SP
	BIC	#^C7600,@SP
	BIC	#7600,2(R0)
	BIS	(SP)+,2(R0)
	BR	5$
;
2$:	BIT	#SYNBIT,FLAGS(R5) ;is receiver in synch
	BEQ	3$		;branch if no
	BIT	#RECBIT,FLAGS(R5) ;yes. is this receive mode
	BNE	3$		;branch if yes
	ADD	FIFGET(R5),R0	;no. assemble next octet
	BR	4$
;
3$:	ADD	#SILENC,R0	;unsynch or receive mode. suppress sidetone
4$:	MOVB	@R0,OUTSHF+1(R5)
	MOV	#8.,OUTCNT(R5)
5$:	INCB	OUTOFS(R5)	;update pointers
	CMPB	OUTOFS(R5),#PRCSIZ ;is this end of parcel
	BLO	7$		;branch if no
	CLRB	OUTOFS(R5)	;yes. update pointers
	BIT	#RECBIT,FLAGS(R5) ;is this receive mode
	BNE	6$		;branch if yes
	DEC	FIFCNT(R5)	;no. is buffer empty
	BNE	6$		;branch if no
	BIC	#XMTBIT+SYNBIT,FLAGS(R5) ;yes. resynch
6$:	ADD	#PRCSIZ,FIFGET(R5)
	CMP	FIFGET(R5),FIFEND(R5)
	BLO	7$
	MOV	FIFBGN(R5),FIFGET(R5)
7$:	MOV	OUTSHF(R5),R0	;is assembly complete
	CMP	R1,OUTCNT(R5)
	BLO	8$		;branch if yes
	NEG	OUTCNT(R5)	;no. go back for more
	ASH	OUTCNT(R5),R0
	ADD	OUTCNT(R5),R1
	BR	1$
;
8$:	NEG	R1		;complete initial shift
	ASH	R1,R0
	MOV	R0,OUTSHF(R5)
	ADD	R1,OUTCNT(R5)
9$:	BIC	#^C377,R0	;extract next 8 bits
	TST	OUTBUF(R2)	;is underrun indicated
	BPL	10$		;branch if no
	INCB	OVERUN+1(R5)
	MOV	#TSOM,R0	;yes. reset indicator
10$:	MOV	R0,OUTBUF(R2)	;send byte
	JMP	LPC30
	.PAGE
;
; Process-state procedure
; Dsects: r3 = par, r5 = psa
;
	.PSECT	$SUPI,RO,I
;
; Initialization
;
LPCINI:	MOV	#INTR,R1	;allocate interrupt vectors
	.SETV
	ADD	#4,R0
	MOV	#INTX,R1
	.SETV
	EMT	INIT		;initialize
;
; Receive and process request
;
LPC9:	MOV	R5,R2		;wait for parameter message
	ADD	#DASPAR,R2
	.GETDA	R2
	MOV	SD.CNT(R2),WRDMAX(R5) ;compute max words
	BIC	#PRCSIZ/2-1,WRDMAX(R5)
	CLR	SD.CNT(R2)
	MOV	#VMBSIZ,VMBCNT(R5)
	MOV	SD.ADR(R2),R1	;map into virtual window
	MOV	#100000,R0
	BISB	SD.DST(R2),R0
	.WIND
	CMPB	#BC.WRT+CHNCTL,SD.CTL(R2) ;is this input
	BNE	5$		;branch if yes
1$:	TST	@R1		;output. is this end-file
	BNE	2$		;branch if no
	TST	2(R1)
	BNE	2$		;branch if no
	TST	4(R1)
	BNE	2$		;branch if no
	TST	6(R1)
	BEQ	13$		;branch if yes
2$:	MOV	@R1,R4		;no. extract repeat count
	BIC	#100000,R4	;is it zero
	BNE	3$		;branch if no
	INC	R4		;yes. treat as one
3$:	CMP	R4,#EOFCNT	;is it valid
	BHIS	13$		;branch if no
4$:	EMT	WRBUF		;yes. get parcel pointer
	MOV	@R1,(R0)+	;copy parcel
	MOV	2(R1),(R0)+
	MOV	4(R1),(R0)+
	MOV	6(R1),(R0)+
	SOB	R4,4$
	ADD	#PRCSIZ,R1	;update pointers
	JSR	PC,VINCR
	BLO	1$
	BR	13$
;
5$:	EMT	RDBUF		;get parcel pointer
	BCS	10$		;branch on end of file (resynch)
	TST	PARCEL(R5)	;is this first parcel
	BNE	6$		;branch if no
	BIT	#7600,2(R0)	;yes. is this silence
	BEQ	5$		;branch if yes
	MOV	(R0)+,PARCEL(R5) ;no. initialize latch
	MOV	(R0)+,PARCEL+2(R5)
	MOV	(R0)+,PARCEL+4(R5)
	MOV	(R0)+,PARCEL+6(R5)
	INC	PARCEL(R5)
	CLR	NVOICE(R5)
	BR	5$
;
6$:	MOV	2(R0),R4	;is this voice
	BIC	#^C177,R4
	CMP	R4,#005
	BNE	7$		;branch if yes
	INC	NVOICE(R5)	;no. update voice interval
	CMP	NVOICE(R5),#EOFCNT ;have we lost our voice
	BLO	8$		;branch if no
	BIS	#EOFBIT,FLAGS(R5) ;yes. flag for eof
	BR	9$
;
7$:	CLR	NVOICE(R5)	;reset voice interval
8$:	BIT	#7600,2(R0)	;is this silence run
	BNE	9$		;branch if no
	BIT	#7600,PARCEL+2(R5)
	BNE	9$		;branch if no
	INC	PARCEL(R5)	;yes. continue run
	BR	5$
;
9$:	MOV	PARCEL(R5),(R1)+ ;copy parcel
	MOV	PARCEL+2(R5),(R1)+
	MOV	PARCEL+4(R5),(R1)+
	MOV	PARCEL+6(R5),(R1)+
	MOV	(R0)+,PARCEL(R5) ;update latch
	MOV	(R0)+,PARCEL+2(R5)
	MOV	(R0)+,PARCEL+4(R5)
	MOV	(R0)+,PARCEL+6(R5)
	INC	PARCEL(R5)
	JSR	PC,VINCR	;update pointers
	BLO	5$
	BR	13$
;
10$:	BISB	#BR.EOF,SD.CTL(R2) ;end of file. fill to block boundary
11$:	TSTB	SD.CNT(R2)
	BEQ	13$
	MOV	#PRCSIZ/2,R4	;fill next parcel	
12$:	CLR	(R1)+
	SOB	R4,12$
	JSR	PC,VINCR	;update pointers
	BLO	11$
13$:	.PUTDA	R2		;send reply message
	JMP	LPC9
;
; Subroutine to increment virtual address and word count
;
VINCR:	ADD	#PRCSIZ,SD.ADR(R2) ;increment virtual address
	DEC	VMBCNT(R5)	;is this about enough for this window
	BNE	1$		;branch if no
	MOV	R0,-(SP)	;yes. map another one
	MOV	#VMBSIZ,VMBCNT(R5)
	MOV	SD.ADR(R2),R1
	MOV	#100000,R0
	BISB	SD.DST(R2),R0
	.WIND
	MOV	(SP)+,R0
1$:	ADD	#PRCSIZ/2,SD.CNT(R2) ;update word count
	CMP	SD.CNT(R2),WRDMAX(R5) ;set condition code
	RTS	PC
	.PAGE
;
; Data segment
;
	.PSECT	$KERD,RO,D
;
; Process header
;
LPCPAT:	.PAT	LPCEND,LPCINI,PRI4,<0,0,LPCNIT,LPCSIR,LPCINR,LPCSIX,LPCINX>
;
; Shift/mask table
;
SHFTAB:	.WORD	-1.,100177	;0
	.WORD	-2.,140077	;1
	.WORD	-3.,160037	;2
	.WORD	-4.,170017	;3
	.WORD	-5.,174007	;4
	.WORD	-6.,176003	;5
	.WORD	-7.,177001	;6
	.WORD	-8.,177400	;7
;
SILENC:	.WORD	000000,000005,00000,00000 ;a parcel of silence
;
	.END
                                                                                                                                                                                                                               